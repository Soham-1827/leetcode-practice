Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
 

Example 1:

Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
Example 2:

Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
Example 3:

Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")

class Solution {
public:
    int countPalindromicSubsequence(string s) {
        unordered_map<char, vector<int>> mp;
        for (int i = 0; i < s.size(); i++) {
            mp[s[i]].push_back(i);
        }

        int ans = 0;
        for (auto &it : mp) {
            const vector<int> &ind = it.second;
            int st = ind[0];
            int e = ind[ind.size() - 1];

            if (e - st <= 1) continue;

            unordered_set<char> mid;
            for (int i = st + 1; i < e; i++) {
                mid.insert(s[i]);
            }

            ans += mid.size();
        }
        return ans;
    }
};


Intuition
A palindromic subsequence of length 3 has the form a _ b _ a.
So for each character a, if we know its first and last occurrence, then any distinct character between them can serve as the middle character.
Thus, for each unique character, count how many distinct characters lie between its first and last indices.

Approach
Store all indices of each character using a hash map.
For each character:
Let st = first index, e = last index.
If e - st <= 1, skip (no space for a middle char).
Otherwise, collect distinct characters between them using a set/map.
Sum the sizes of these sets.
Complexity
Time Complexity:
( O(n) ) — each index is processed at most a constant number of times.
Space Complexity:
( O(1) ) — only storing positions for 26 lowercase letters.
