You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the integers from starti to endi inclusively.

A containing set is an array nums where each interval from intervals has at least two integers in nums.

For example, if intervals = [[1,3], [3,7], [8,9]], then [1,2,4,7,8,9] and [2,3,4,8,9] are containing sets.
Return the minimum possible size of a containing set.

 

Example 1:

Input: intervals = [[1,3],[3,7],[8,9]]
Output: 5
Explanation: let nums = [2, 3, 4, 8, 9].
It can be shown that there cannot be any containing array of size 4.
Example 2:

Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
Output: 3
Explanation: let nums = [2, 3, 4].
It can be shown that there cannot be any containing array of size 2.
Example 3:

Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
Output: 5
Explanation: let nums = [1, 2, 3, 4, 5].
It can be shown that there cannot be any containing array of size 4.
 

Constraints:

1 <= intervals.length <= 3000
intervals[i].length == 2
0 <= starti < endi <= 108

class Solution {
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){ 
            if (a[1] == b[1]) return a[0] > b[0];
            return a[1] < b[1]; 
        });

        vector<int> points; 
        points.push_back(intervals[0][1] - 1);
        points.push_back(intervals[0][1]);

        for(int i = 1; i < intervals.size(); i++){
            int start = intervals[i][0];
            int end = intervals[i][1];

            int covered = 0;
            for (int point : points) {
                if (point >= start && point <= end) {
                    covered++;
                }
            }

            if (covered == 0) {
                // No points cover it - add 2 points
                points.push_back(end - 1);
                points.push_back(end);
            }
            else if (covered == 1) {
                // Only 1 point covers it - add 1 point
                points.push_back(end);
            }
        }
        return points.size();
    }
};



Thinking process:-
Thinking Approach (Greedy Strategy)
Step-by-Step Thinking:
1️⃣ Why sort by end point?

We want to handle intervals that end earliest first
This allows us to place points that can potentially cover future intervals too
Greedy principle: Place points as late (rightmost) as possible in each interval

2️⃣ Why place points at the END of intervals?

Points at the end have the best chance of covering future intervals
Example: If interval is [1, 5], placing points at 4, 5 is better than 1, 2

Because future intervals like [3, 7] are more likely to be covered



3️⃣ Why start with 2 points in the first interval?

Every interval needs at least 2 points from our set
So we initialize with 2 points at the end of the first interval: [end-1, end]

4️⃣ For each subsequent interval, check coverage:
Current interval: [start, end]
Check: How many of our existing points fall in [start, end]?
Three cases:
CoverageMeaningAction0 pointsInterval not covered at allAdd 2 new points: end-1, end1 pointInterval partially coveredAdd 1 new point: end2+ pointsInterval fully coveredDo nothing
5️⃣ Why add points at end-1 and end?

Same reasoning: maximize coverage for future intervals
These are the rightmost positions in the current interval


Visual Example:
Intervals after sorting:
[1, 3], [2, 4], [3, 5], [4, 6]

Step 1: Start with first interval [1, 3]
Points: [2, 3]
        |  |
    [1, 2, 3]

Step 2: Check [2, 4]
Points [2, 3] both in [2, 4] ✓
Coverage: 2 → Do nothing
Points: [2, 3]

Step 3: Check [3, 5]
Only point 3 is in [3, 5] ✓
Coverage: 1 → Add point 5
Points: [2, 3, 5]
           |     |
       [3, 4, 5]

Step 4: Check [4, 6]
Only point 5 is in [4, 6] ✓
Coverage: 1 → Add point 6
Points: [2, 3, 5, 6]

Answer: 4 points needed

Key Insights:

Greedy = Always place points as far right as possible

Maximizes future interval coverage


Sort by end point = Process in optimal order

Earlier endpoints get handled first


Check existing points = Avoid redundancy

Only add points when needed


Always add at the end = Optimal placement

Best position to cover future intervals




Algorithm Summary:
1. Sort intervals by end point (ascending)
2. Initialize with 2 points at end of first interval
3. For each remaining interval:
   - Count how many existing points cover it
   - Add minimum needed points (0, 1, or 2) at the END
4. Return total points added
