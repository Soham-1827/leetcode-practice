You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.

Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
Output: 2
Explanation: There are two paths where the sum of the elements on the path is divisible by k.
The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.
The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.
Example 2:


Input: grid = [[0,0]], k = 5
Output: 1
Explanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.
Example 3:


Input: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1
Output: 10
Explanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.

Solution:-
class Solution {
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        int m = grid.size();
        int n = grid[0].size();
        
        // Memoization table: dp[row][col][remainder]
        // -1 means not computed yet
        vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(k, -1)));
        
        return dfs(grid, 0, 0, grid[0][0] % k, k, m, n, memo);
    }

private:
    int dfs(vector<vector<int>>& grid, int row, int col, int currRemainder, int k, int m, int n,
            vector<vector<vector<int>>>& memo){
        const int MOD = 1e9 + 7;  // Fixed: was 10e9, should be 1e9
        
        if(row == m - 1 && col == n - 1){
            return (currRemainder == 0) ? 1 : 0;
        }
        
        // Check if already computed
        if(memo[row][col][currRemainder] != -1){
            return memo[row][col][currRemainder];
        }

        int paths = 0;

        if(row + 1 < m){
            paths = (paths + dfs(grid, row + 1, col, 
                                (currRemainder + grid[row + 1][col]) % k, 
                                k, m, n, memo)) % MOD;
        }

        if(col + 1 < n){
            paths = (paths + dfs(grid, row, col + 1, 
                                (currRemainder + grid[row][col + 1]) % k, 
                                k, m, n, memo)) % MOD;
        }
        
        // Store in memo before returning
        memo[row][col][currRemainder] = paths;
        return paths;
    }
};

Problem Summary

Start at (0, 0), reach (m-1, n-1)
Can only move right or down
Count paths where sum of elements is divisible by k
Return answer modulo 10^9 + 7


Approach: DFS + Memoization (Top-Down DP)
Step 1: Basic DFS Structure
DFS Function Parameters:
cppdfs(grid, row, col, currRemainder, k, m, n, memo)

row, col: current position
currRemainder: current path sum % k (we only need remainder, not full sum!)
k: the divisor
m, n: grid dimensions
memo: memoization table

Base Case:
cppif (row == m-1 && col == n-1) {
    return (currRemainder == 0) ? 1 : 0;
}

If at destination and remainder is 0, path is valid → return 1
Otherwise → return 0

Recursive Cases:
cpp// Move down
if (row + 1 < m) {
    paths += dfs(..., row+1, col, (currRemainder + grid[row+1][col]) % k, ...)
}

// Move right
if (col + 1 < n) {
    paths += dfs(..., row, col+1, (currRemainder + grid[row][col+1]) % k, ...)
}

Step 2: Why Plain DFS Gets TLE?
Without memoization:

Time Complexity: O(2^(m+n)) - exponential!
Many overlapping subproblems
Same state (row, col, remainder) computed multiple times

Example: Position (1,1) with remainder 1 can be reached via:

Path 1: (0,0) → (0,1) → (1,1)
Path 2: (0,0) → (1,0) → (1,1)

Both would recalculate everything from (1,1) onwards!

Step 3: Add Memoization
Memoization Table:
cppvector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(k, -1)));

3D array: memo[row][col][remainder]
Stores: "Number of valid paths from (row, col) to destination when current sum has remainder"
Initialize with -1 (meaning "not computed yet")

Memoization Logic:
cpp// Before computing, check if already solved
if (memo[row][col][currRemainder] != -1) {
    return memo[row][col][currRemainder];
}

// Compute the answer
int paths = ...recursive calls...

// Store before returning
memo[row][col][currRemainder] = paths;
return paths;

