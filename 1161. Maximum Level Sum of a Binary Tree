Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.

Return the smallest level x such that the sum of all the values of nodes at level x is maximal.

 

Example 1:


Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
Example 2:

Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-105 <= Node.val <= 105

class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        unordered_map<int, int> m; //level, sum
        if(root == NULL){
            return 0;
        }
        int level = 0;
        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()){
            level++;
            int sum = 0;
            int n = q.size();
            for(int i = 0; i < n; i++){
                TreeNode* node = q.front();
                q.pop();
                sum += node->val;

                if(node->left != NULL){
                    q.push(node->left);
                }

                if(node->right != NULL){
                    q.push(node->right);
                }
            }
            m[level] = sum;  // changed: store level -> sum
        }

        int maximum = INT_MIN;  // changed: use INT_MIN for negative values
        int result = 1;  // added: track the result level
        for(auto it = m.begin(); it != m.end(); it++){
            if(it->second > maximum || (it->second == maximum && it->first < result)){  // changed: check sum and handle ties
                maximum = it->second;
                result = it->first;
            }
        }
        return result;  // changed: return result instead of m[maximum]
    }
};
